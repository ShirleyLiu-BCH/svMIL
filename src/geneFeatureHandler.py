#!/usr/bin/env python######### Documentation #########__author__ = "Marleen Nieboer"__credits__ = []__maintainer__ = "Marleen Nieboer"__email__ = "m.m.nieboer@umcutrecht.nl"__status__ = "Development"### Imports ###import syssys.path.append('settings/') #Add settings pathimport settingsimport numpy as npimport time### Code ###class GeneFeatureHandler:	"""		This class is a handler for computing features related to genes. This function should be called from a database handler, such as the FlatFileDb class. It should have one return value, which contains annotations.	"""	def annotate(self, regions, geneData, enabledFeatures = None):		"""			The annotate function is mandatory. This function should be called from a database handler, such as the FlatFileDb class. It should have one return value, which contains annotations.						Parameters:				regions (numpy matrix): a Numpy matrix of dtype 'object' with on the columns chr 1, s1, e1, chr2, s2, e2, and the regions on the rows.				geneData (numpy matrix): a Numpy matrix of dtype 'object' with on the columns chr, start, end, pLI, RVIS, HPO ids, HGNC symbol, and the genes on the rows. 				enabledFeatures (list): optional. Not yet implemented. The idea is that a list can be provided that contains the names of features that are enabled in the settings. If necessary, the listed features				can be excluded from computation to save computational time. It can be easily implemented by having an if statement checking for that in this function.							Returns:				annotations (dict): a dictionary with annotations. {'featureName' : [values]}, where the values are in the same order as the provided regions. The value must be a list to guarantee that data is				written to the output file in the same manner, even if it has only 1 value. 		"""		#Determine the genes within x Mb (defined in settings) 		annotations = self.computeNearestGeneFeatures(regions, geneData)		return annotations		def computeNearestGeneFeatures(self, regions, geneListData):		"""			Checks which genes are within x Mb, as defined in the settings. First, a subset is made containing all genes on chr1 or chr2 on which the region is located. All genes within +/- x Mb of the s1 and e2			coordinate of the region are obtained. For each of these genes, features are computed.						Returns:				annotations (dict): dictionary with all features related to genes, containing:				- nearestGeneDistance (int): bad name, needs to be fixed, now contains the number of genes within +/- x Mb				- pLi (list): the pLI score of each gene				- RVIS (list): the RVIS score of each gene				- HPO (list): HPO terms associated with each gene							TODO:				- Fix feature names				- Split function in separate sub-functions, improving readability				"""				#Keep the annotations as a dictionary		annotations = dict()		annotations['nearestGeneDistance'] = [] #save as a list where every entry is the nearest gene distance for an SV		annotations['pLI'] = []		annotations['RVIS'] = []		annotations['HPO'] = [] 		#The input regions are sorted, so we can make chromosomal subsets. 				previousChr1 = None		previousChr2 = None		startTime = time.time()		for lineCount in range(0, len(regions)):			#print lineCount			#Make sure to filter the dataset per chromosome! Good when sorted, we can keep it until we hit the next chromosome			#The genes are not cross-chromosomal, but translocations can be, so we need to check both chromosome entries!						#Obtain start and end positions and chromosome (chr 1 and 2)			lineList = regions[lineCount,:]						#print geneListData						#We should check the chromosome of the previous line.			#This would work nicely if the input file has been properly sorted! We probably need a pre-sorting to make this work. 			if str(lineList[0]) != previousChr1 and str(lineList[3]) != previousChr2:								#Find the two subsets that match on both chromosomes. 				matchingChr1Ind = geneListData[:,0] == lineList[0]				matchingChr2Ind = geneListData[:,0] == lineList[3] #The gene list entry is here the same since the genes are only on 1 chromosome. 								#It is not even necessary to make 2 lists if both chromosomes are the same, we could use a reference without re-allocating				geneListChr1Subset = geneListData[np.where(matchingChr1Ind)]				if lineList[0] == lineList[3]:					geneListChr2Subset = geneListChr1Subset				else:					geneListChr2Subset = geneListData[np.where(matchingChr2Ind)]								#Make sure to update the previous chromosome when it changes				previousChr1 = str(lineList[0])				previousChr2 = str(lineList[3])										if np.size(geneListChr1Subset) < 1 and np.size(geneListChr2Subset) < 1:				continue #no need to compute the distance, there are no genes on these chromosomes						#It is a bit inefficient to do the astype here, but I already cast to int in the annotation tester, why did it get lost?			#If the chromosomes are the same, the end position of the SV is in the chr2 column! Keep this in mind.			if lineList[0] == lineList[3]: #If the chromosomes are the same				start = lineList[1].astype(int) #only do the conversion once. Why is this not remembered from the previous loop?				end = lineList[5].astype(int)			else: #if the chromosomes are not the same, then we only use the positions of chromosome 1. 				start = lineList[1].astype(int) 				end = lineList[2].astype(int)						#Instead of the nearest gene, we can look at all genes within 2 Mb of the SV						geneDistance = settings.parameters['geneDistance']						#Compute the absolute distance, then remove the genes that are not within 2Mb and use this as a subset.						#The genes are assumed to be sorted, so we can compute if these are within 2Mb by only comparing the nearest coordinate.					startOverlap = start - geneDistance < geneListChr1Subset[:,2] 			endOverlap = end + geneDistance > geneListChr1Subset[:,1]						#Now find where both of these are true (multiply because both conditions need to be true)			distanceMatchesChr1 = startOverlap * endOverlap						#Repeat for the second chromosome			if lineList[0] == lineList[3]: #If the chromosomes are the same				start = lineList[1].astype(int) #only do the conversion once. Why is this not remembered from the previous loop?				end = lineList[5].astype(int)			else: #if the chromosomes are not the same, then we only use the positions of chromosome 2. 				start = lineList[4].astype(int) 				end = lineList[5].astype(int)						startOverlap = start - geneDistance < geneListChr2Subset[:,2] 			endOverlap = end + geneDistance > geneListChr2Subset[:,1]						distanceMatchesChr2 = startOverlap * endOverlap						#obtain indices of matches, obtain the information of these genes						matchIndChr1 = np.where(distanceMatchesChr1 == True)[0] #This creates an array in array, we are only interested in the first that contains the matching indices			matchIndChr2 = np.where(distanceMatchesChr2 == True)[0]						matchingGenesChr1 = geneListChr1Subset[matchIndChr1, :]			matchingGenesChr2 = geneListChr2Subset[matchIndChr2, :]						#Obtain information about the matching genes (for now only the identifier)						#geneIdsChr1 = matchingGenesChr1[:,6]			#geneIdsChr2 = matchingGenesChr2[:,6]									#geneIds = set(np.concatenate((geneIdsChr1, geneIdsChr2), axis=0))						matchingGenes = np.concatenate((matchingGenesChr1, matchingGenesChr2), axis=0)			geneIds = matchingGenes[:,6]			#store the number of genes in annotations. Later the indices or identifiers would be relevant (multiple features, linking)			annotations['nearestGeneDistance'].append(len(geneIds))												#For each of these genes, also report the pLI and RVIS scores (hpo terms? not yet relevant)			pLiScores = []			rvisScores = []			for gene in matchingGenes:												pLi = gene[3]				RVIS = gene[4]				pLiScores.append(pLi)				rvisScores.append(RVIS)						annotations['pLI'].append(','.join(pLiScores))			annotations['RVIS'].append(','.join(rvisScores))					endTime = time.time()		print "total time to query: ", endTime - startTime		return annotations	#More functions to be added 				